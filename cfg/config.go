package cfg

import (
	"context"
	"github.com/rs/xid"
	"github.com/veypi/webds/core"
	"net/http"
	"time"
)

const (
	// DefaultWebsocketWriteTimeout 0, no timeout
	DefaultWebsocketWriteTimeout = 0
	// DefaultWebsocketReadTimeout 0, no timeout
	DefaultWebsocketReadTimeout = 0
	// DefaultWebsocketPongTimeout 60 * time.Second
	DefaultWebsocketPongTimeout = 60 * time.Second
	// DefaultWebsocketPingPeriod (DefaultPongTimeout * 9) / 10
	DefaultWebsocketPingPeriod = (DefaultWebsocketPongTimeout * 9) / 10
	// DefaultWebsocketMaxMessageSize 1024
	DefaultWebsocketMaxMessageSize = 1024
	// DefaultWebsocketReadBufferSize 4096
	DefaultWebsocketReadBufferSize = 4096
	// DefaultWebsocketWriterBufferSize 4096
	DefaultWebsocketWriterBufferSize = 4096
	// DefaultEvtMessageKey is the default prefix of the underline websocket events
	// that are being established under the hoods.
	//
	// Last character of the prefix should be ':'.
)

// DefaultIDGenerator returns a random unique for a new conn.
// Used when cfg.IDGenerator is nil.
func DefaultIDGenerator(r *http.Request) string {
	id := r.Header.Get("id")
	if len(id) != 0 {
		return id
	}
	return xid.New().String()
}

// Config the websocket server configuration
// all of these are optional.
type Config struct {
	// the server id
	ID string
	// IDGenerator used to create (and later on, set)
	// an ID for each incoming websocket connections (clients).
	// The request is an input parameter which you can use to generate the ID (from headers for example).
	// If empty then the ID is generated by DefaultIDGenerator: randomString(64)
	IDGenerator func(r *http.Request) string
	// record the address of another node
	ClusterMasters []string
	EnableCluster  bool
	// 本节点级别: 0 为非cluster node节点，无法接收链接；  1 为最高级节点
	ClusterLevel uint
	// 连接策略
	// 0： 多(本级) -> 1（本级） -> 1 （高级） 即在本级节点选举出一个当做代表
	// 1： 多(本级)  -> 1（高级）
	ClusterMode uint
	// 是否开启自动检测目标地址
	EnableAutoDetect bool
	// 监听端口访问，只监听1个，失败会port+1再次尝试， 自动检测也是在该范围内检测节点
	ClusterPortMin uint
	ClusterPortMax uint
	// 是否对连接目标地址添加或替换后缀
	ClusterSuffix string
	//
	// CheckOrigin a function that is called right before the handshake,
	// if returns false then that client is not allowed to connect with the websocket server.
	CheckOrigin func(r *http.Request) bool
	// WriteTimeout time allowed to write a message to the conn.
	// 0 means no timeout.
	// Default value is 0
	WriteTimeout time.Duration
	// ReadTimeout time allowed to read a message from the conn.
	// 0 means no timeout.
	// Default value is 0
	readTimeout time.Duration
	// PongTimeout allowed to read the next pong message from the conn.
	// Default value is 60 * time.Second
	pongTimeout time.Duration
	// PingPeriod send ping messages to the conn within this period. Must be less than PongTimeout.
	// Default value is 60 *time.Second
	pingPeriod time.Duration
	// MaxMessageSize max message size allowed from conn.
	// Default value is 1024
	maxMessageSize int64
	// ReadBufferSize is the buffer size for the conn reader.
	// Default value is 4096
	readBufferSize int64
	// WriteBufferSize is the buffer size for the conn writer.
	// Default value is 4096
	writeBufferSize int
	// EnableCompression specify if the server should attempt to negotiate per
	// message compression (RFC 7692). Setting this value to true does not
	// guarantee that compression will be supported. Currently only "no context
	// takeover" modes are supported.
	//
	// Defaults to false and it should be remain as it is, unless special requirements.
	EnableCompression bool

	ctx   context.Context
	webds core.Webds
}

func (c *Config) Ctx() context.Context {
	return c.ctx
}

func (c *Config) Webds() core.Webds {
	return c.webds
}

func (c *Config) SetWebds(w core.Webds) {
	c.webds = w
}

func (c *Config) PingPeriod() time.Duration {
	return c.pingPeriod
}

func (c *Config) ReadTimeout() time.Duration {
	return c.readTimeout
}

func (c *Config) ReadBufferSize() int64 {
	return c.readBufferSize
}

// Validate validates the configuration
func (c *Config) Validate() {
	if c.ID == "" {
		c.ID = xid.New().String()
	}
	if c.ctx == nil {
		c.ctx = context.Background()
	}
	// 0 means no timeout.
	if c.WriteTimeout < 0 {
		c.WriteTimeout = DefaultWebsocketWriteTimeout
	}

	if c.readTimeout < 0 {
		c.readTimeout = DefaultWebsocketReadTimeout
	}

	if c.pongTimeout < 0 {
		c.pongTimeout = DefaultWebsocketPongTimeout
	}

	if c.pingPeriod <= 0 {
		c.pingPeriod = DefaultWebsocketPingPeriod
	}

	if c.maxMessageSize <= 0 {
		c.maxMessageSize = DefaultWebsocketMaxMessageSize
	}

	if c.readBufferSize <= 0 {
		c.readBufferSize = DefaultWebsocketReadBufferSize
	}

	if c.writeBufferSize <= 0 {
		c.writeBufferSize = DefaultWebsocketWriterBufferSize
	}

	if c.CheckOrigin == nil {
		c.CheckOrigin = func(r *http.Request) bool {
			// allow all connections by default
			return true
		}
	}

	if c.IDGenerator == nil {
		c.IDGenerator = DefaultIDGenerator
	}
	if c.ClusterPortMin == 0 {
		c.ClusterPortMin = 10086
	}
	if c.ClusterPortMax == 0 {
		c.ClusterPortMax = 10186
	}
	if c.EnableCluster && c.ClusterLevel == 0 {
		panic("please define the cluster level or target level")
	}
}
